<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  leadedx
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="leadedx" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:leadedx.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; leadedx</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="datamesh.html">Data Mesh</a></li>
        
            <li><a href="System%20architecture.html">System architecture</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Books.html">Books</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="shu-ju-wang-ge-yuan-ze-yu-luo.html">
                
                  <h1>数据网格原则与逻辑架构</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>数据网格原则与逻辑架构是一种现代的数据管理方法，旨在提高数据的可访问性、可维护性和价值创造。以下是数据网格的核心原则和逻辑架构的总结归纳：</p>
</blockquote>
<blockquote>
<h3><a id="%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心原则</h3>
</blockquote>
<blockquote>
<ol>
<li><strong>面向领域的分散式数据所有权和架构</strong>：
<ul>
<li>数据管理的责任和控制权分散到各个业务领域，每个领域都有专门的团队负责数据的收集、存储、处理和分发。这种分散化的方法有助于提高数据的可访问性和可维护性，同时促进跨领域的协作和数据共享。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>数据即产品</strong>：
<ul>
<li>数据被视为一种产品，需要关注其质量、可用性和用户体验。数据产品化鼓励团队像对待商业产品一样对待数据，包括品牌化、营销和持续改进，确保数据对消费者来说是有用和可信赖的。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>自助式数据基础设施作为平台</strong>：
<ul>
<li>建立一个自助服务平台，使得用户能够轻松地发现、访问和使用数据，而无需深入了解底层技术和复杂的数据处理流程。这种基础设施降低了技术门槛，提高了数据的可消费性。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>联合计算治理</strong>：
<ul>
<li>计算治理是分散的，但是通过联合的方式进行协调和管理。不同的数据领域可以独立地进行计算和分析，同时保持整体的数据一致性和合规性。这种治理模式提高了数据处理的效率和响应速度，同时确保数据的安全和隐私。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<h3><a id="%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑架构</h3>
</blockquote>
<blockquote>
<ol>
<li><strong>领域导向的数据分解和所有权</strong>：
<ul>
<li>组织根据业务领域进行分解，每个领域负责管理自己的数据和计算资源。这种架构支持领域内的自治和领域间的协作，同时减少了数据孤岛和提高了数据的流动性。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>数据产品作为架构量子</strong>：
<ul>
<li>数据产品是最小的独立部署单元，具有高功能内聚性，并包括所有必要的结构元素，如代码、数据和元数据、基础设施等。这种设计使得数据产品可以独立于其他领域进行开发和维护。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>多平面数据平台</strong>：
<ul>
<li>数据平台由多个平面组成，每个平面服务于不同的用户配置文件和需求。这些平面可能包括数据基础设施配置平面、数据产品开发者体验平面和数据网格监管平面等，每个平面都提供了一组相关的自助式服务和工具。</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>通过这些原则和逻辑架构，数据网格方法论旨在构建一个灵活、可扩展且可持续发展的数据生态系统，以适应不断变化的技术和市场需求。这种方法有助于组织更好地利用数据资源，推动数据驱动的决策和创新，最终实现业务增长和竞争优势。<br />
我们渴望利用数据来增强和改善商业和生活的每一个方面，这要求我们在大规模数据管理方面进行范式转变。尽管过去十年的技术进步已经解决了数据量和数据处理计算的规模问题，但它们未能解决其他维度的规模问题：数据景观的变化、数据来源的激增、数据用例和用户的多样性以及对变化响应的速度。数据网格针对这些维度提供了解决方案，建立在四个原则之上：面向领域的分散式数据所有权和架构、数据即产品、自助式数据基础设施作为平台、以及联合计算治理。每个原则都推动了技术架构和组织结构的新逻辑视角的形成。</p>
</blockquote>
<blockquote>
<ol>
<li><strong>面向领域的分散式数据所有权和架构</strong>：这一原则强调数据应该根据其业务领域进行管理和组织，每个领域都有其负责人和团队，他们对数据的收集、存储、处理和分发负有完全的责任。这种分散化的方法有助于提高数据的可访问性和可维护性，同时促进跨领域的协作和数据共享。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong>数据即产品</strong>：将数据视为一种产品，意味着我们需要关注数据的质量、可用性和用户体验。数据产品化鼓励团队像对待任何其他商业产品一样对待数据，包括对其进行品牌化、营销和持续改进。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><strong>自助式数据基础设施作为平台</strong>：这一原则提倡建立一个平台，使得用户能够轻松地发现、访问和使用数据，而无需深入了解底层技术和复杂的数据处理流程。这种基础设施的自助服务特性，可以降低技术门槛，提高数据的可消费性。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><strong>联合计算治理</strong>：在数据网格中，计算治理是分散的，但是通过联合的方式进行协调和管理。这意味着不同的数据领域可以独立地进行计算和分析，同时保持整体的数据一致性和合规性。这种治理模式有助于提高数据处理的效率和响应速度，同时确保数据的安全和隐私。</li>
</ol>
</blockquote>
<blockquote>
<p>通过这些原则，组织可以更好地管理和利用其数据资源，以支持快速决策、创新和业务增长。同时，这也有助于构建一个更加灵活和可扩展的数据生态系统，以适应不断变化的技术和市场需求。</p>
</blockquote>
<p>本文旨在作为后续跟进文章，总结了数据网格方法，列举了其支撑原则和原则所驱动的高级逻辑架构。在我未来的文章中深入探讨数据网格核心组件的详细架构之前，建立高级逻辑模型是一个必要的基础。因此，如果你在寻找关于数据网格确切工具和方法的具体处方，本文可能会让你失望。如果你寻求的是一个简单且与技术无关的模型，该模型建立了共同的语言，请加入我们。</p>
<p>在上一篇文章《如何从单一数据湖迈向分布式数据网格》中，我强调了当今在架构和组织挑战方面的痛点，以便成为数据驱动型企业，利用数据竞争，或利用大规模数据创造价值。它提供了一种替代视角，自那以后吸引了许多组织的注意，并为不同的未来带来了希望。虽然原文描述了这种方法，但它将许多设计和实施的细节留给了读者的想象。在本文中，我没有意图过于规定性，扼杀围绕数据网格实施的想象和创造力。但我认为，为了推动范式向前发展，阐明数据网格的架构方面是负责任的。</p>
<p>本文的写作目的是为了提供一个后续的总结。它通过列举数据网格方法的基本原则和这些原则所推动的高级逻辑架构来概括数据网格方法。在我未来的文章中深入探讨数据网格核心组件的详细架构之前，建立高级逻辑模型是一个必要的基础。因此，如果你正在寻找关于数据网格确切工具和方法的具体处方，本文可能会让你失望。如果你寻求的是一个简单且与技术无关的模型，该模型建立了共同的语言，那么请继续阅读。</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E7%9A%84%E9%B8%BF%E6%B2%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据的鸿沟</h2>
<p>我们所说的“数据”究竟指的是什么？这个问题的答案取决于你询问的对象。如今的数据景观被划分为操作数据和分析数据。操作数据存放在支持微服务的业务能力背后的数据库中，具有交易性质，保持当前状态并满足运行业务的应用程序的需求。分析数据是随时间变化的业务事实的聚合视图，通常被建模以提供回顾性或前瞻性的洞察；它用于训练机器学习模型或提供分析报告。</p>
<p>目前的技术、架构和组织设计反映了这两个数据平面的分歧——两种存在层面，虽然集成但又是分离的。这种分歧导致了脆弱的架构。对于许多试图连接这两个平面的人来说，持续失败的ETL（提取、转换、加载）作业和日益增长的复杂数据管道迷宫，是一个熟悉的景象，数据从操作数据平面流向分析数据平面，然后再流回操作数据平面。</p>
<p>这种数据鸿沟的存在，不仅在技术上造成了挑战，也在组织结构和文化上造成了隔阂。操作团队和分析团队往往有着不同的目标、工具集和工作流程，这导致了数据孤岛的出现和数据治理的困难。操作数据的关注点在于确保数据的实时性和准确性，以支持日常业务运作；而分析数据则更侧重于数据的深度挖掘和长期价值的发现。<br />
为了克服这些挑战，我们需要重新思考数据管理的方式，寻找能够更好地整合操作和分析数据的方法。这就需要我们采用新的思维模式和架构设计，比如数据网格，它提倡将数据分散到各个领域，并通过产品化、自助服务和联合治理的方式，来提高数据的可用性和价值创造。<br />
通过这种方式，我们可以更好地利用数据来驱动业务创新和竞争优势，同时也能够提高数据的质量和治理水平，实现数据的可持续发展。<br />
<img src="media/17117904284058/17117905657166.jpg" alt="" />图1：数据的鸿沟</p>
<p>分析数据平面本身已经分化为两种主要的架构和技术栈：数据湖和数据仓库；数据湖支持数据科学的访问模式，而数据仓库支持分析和商业智能报告的访问模式。在这次讨论中，我将搁置这两种技术栈之间的互动：数据仓库试图引入数据科学工作流程，而数据湖试图服务于数据分析师和商业智能。<br />
原始的关于数据网格的讨论探索了现有分析数据平面架构的挑战。</p>
<p>在当前的数据管理和分析实践中，数据湖和数据仓库各自扮演着重要的角色，但它们也面临着一些挑战和限制。</p>
<p>数据湖旨在存储大量的非结构化和半结构化数据，提供了灵活的数据存储和处理能力，以支持数据科学和大数据分析。然而，数据湖的灵活性也带来了一些挑战，比如数据的治理和质量控制难度较大，以及对于数据分析师和业务智能用户来说，直接从数据湖中获取数据并进行分析的门槛较高。</p>
<p>另一方面，数据仓库则专注于为结构化数据提供高效的查询和报告能力，支持商业智能和数据分析应用。但是，数据仓库对于处理非结构化数据和实时数据的能力有限，而且在快速变化的业务需求和新兴技术面前，数据仓库的可扩展性和灵活性可能不足。</p>
<p>因此，我们需要一种新的方法来解决这些挑战，这正是数据网格方法所提倡的。数据网格通过将数据分解为更小、更易于管理的单元，并将这些单元分配给特定的业务领域，使得数据的所有权和责任更加明确。这种方法不仅能够提高数据的可访问性和可用性，还能够促进跨领域的协作和数据共享，从而更好地支持数据驱动的决策和创新。<br />
在未来的文章中，我们将深入探讨数据网格核心组件的详细架构，以及如何将这些原则和技术应用到实际的业务场景中，以实现数据管理和分析的现代化。<br />
<img src="media/17117904284058/17117906858675.jpg" alt="" /><br />
Figure 2: Further divide of analytical data - warehouse<br />
<img src="media/17117904284058/17117907021605.jpg" alt="" /><br />
Figure 3: Further divide of analytical data - lake</p>
<p>数据网格认可并尊重这两个平面之间的差异：数据的性质和拓扑结构、不同的用例、数据消费者的个体特征，以及最终他们多样化的访问模式。然而，它试图在一个不同的结构下连接这两个平面——一个基于领域的倒置模型和拓扑结构，而不是基于技术栈，并专注于分析数据平面。当今可用于管理这两种数据原型的技术差异，不应导致组织、团队和从事这些工作的人员的分离。在我看来，操作性和交易性数据技术和拓扑已相对成熟，并且在很大程度上由微服务架构推动；数据隐藏在每个微服务的内部，通过微服务的API进行控制和访问。是的，在实现真正的多云原生操作数据库解决方案方面，创新的空间仍然存在，但从架构的角度来看，它满足了业务的需求。然而，正是对分析数据的管理和访问，在大规模上仍然是一个摩擦点。这正是数据网格关注的地方。</p>
<p>我确实相信，在未来的某个时候，我们的技术将发展到使这两个平面更加紧密地结合在一起，但就目前而言，我建议我们保持它们各自的关注点分开。</p>
<p>数据网格的方法论提供了一种新的视角，以领域为中心来组织和管理数据，而不是依赖于传统的技术栈。这种方法强调了数据的领域属性，将数据视为独立的、自治的实体，每个实体都有自己的生命周期、治理和访问模式。通过这种方式，数据网格试图弥合操作数据平面和分析数据平面之间的鸿沟，同时保持它们的独立性和专业化。<br />
数据网格鼓励在组织内部建立一个更加分散的数据治理模型，其中数据团队和业务团队共同负责数据的质量、安全性和可用性。这种模型不仅能够提高数据的效率和响应速度，还能够促进跨部门和团队的协作，从而更好地支持数据驱动的决策和创新。<br />
尽管我们期待着未来技术的进步能够进一步缩小操作数据和分析数据之间的差距，但在目前阶段，数据网格提供了一种切实可行的解决方案，以应对大规模分析数据管理的挑战。通过采用数据网格原则，组织可以更好地利用数据来推动业务增长和创新，同时确保数据的质量和合规性。</p>
<h3><a id="%E6%95%B0%E6%8D%AE%E7%BD%91%E6%A0%BC%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99%E5%92%8C%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据网格的核心原则和逻辑架构</h3>
<p>数据网格的目标是在大规模上从分析数据和历史事实中获取价值——这里的“规模”指的是数据景观的不断变化、数据来源和消费者的激增、使用案例所需的多样性转换和处理，以及对变化的快速响应。为了实现这一目标，我认为有四个基本原则是任何数据网格实施所体现的，以实现规模的承诺，同时提供必要的质量和完整性保证，使数据可用：1）面向领域的分散式数据所有权和架构，2）数据即产品，3）自助式数据基础设施作为平台，4）联合计算治理。</p>
<p>虽然我预期这些原则的实践、技术和实施会随着时间的推移而变化和成熟，但这些原则本身保持不变。</p>
<p>我期望这四个原则是集体必要且充分的；在实现规模和弹性的同时，解决关于数据孤岛化或运营成本增加的担忧。让我们深入探讨每个原则，然后设计支持它的概念架构。</p>
<ol>
<li>
<p><strong>面向领域的分散式数据所有权和架构</strong>：这一原则强调数据应该根据其业务领域进行管理和组织，每个领域都有其负责人和团队，他们对数据的收集、存储、处理和分发负有完全的责任。这种分散化的方法有助于提高数据的可访问性和可维护性，同时促进跨领域的协作和数据共享。</p>
</li>
<li>
<p><strong>数据即产品</strong>：将数据视为一种产品，意味着我们需要关注数据的质量、可用性和用户体验。数据产品化鼓励团队像对待任何其他商业产品一样对待数据，包括对其进行品牌化、营销和持续改进。</p>
</li>
<li>
<p><strong>自助式数据基础设施作为平台</strong>：这一原则提倡建立一个平台，使得用户能够轻松地发现、访问和使用数据，而无需深入了解底层技术和复杂的数据处理流程。这种基础设施的自助服务特性，可以降低技术门槛，提高数据的可消费性。</p>
</li>
<li>
<p><strong>联合计算治理</strong>：在数据网格中，计算治理是分散的，但是通过联合的方式进行协调和管理。这意味着不同的数据领域可以独立地进行计算和分析，同时保持整体的数据一致性和合规性。这种治理模式有助于提高数据处理的效率和响应速度，同时确保数据的安全和隐私。</p>
</li>
</ol>
<p>通过这些原则，组织可以更好地管理和利用其数据资源，以支持快速决策、创新和业务增长。同时，这也有助于构建一个更加灵活和可扩展的数据生态系统，以适应不断变化的技术和市场需求。在未来的文章中，我们将深入探讨数据网格核心组件的详细架构，以及如何将这些原则和技术应用到实际的业务场景中，以实现数据管理和分析的现代化。</p>
<h2><a id="%E9%A2%86%E5%9F%9F%E6%89%80%E6%9C%89%E6%9D%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>领域所有权</h2>
<p>数据网格的核心理念在于分散化和分布责任，将责任交给最接近数据的人，以支持持续的变革和可扩展性。问题在于，我们如何分解和分散数据生态系统的组件及其所有权。这里的组件由分析数据、其元数据以及提供服务所需的计算组成。</p>
<p>数据网格遵循组织单元的接缝作为分解的轴线。我们今天的组织是基于其业务领域进行分解的。这种分解将连续变化和演变的影响局部化，大部分局限于领域的有界上下文中。因此，将业务领域有界上下文作为数据所有权分布的良好候选者。</p>
<p>在本文中，我将继续使用原始文档中的相同用例——“一家数字媒体公司”。可以想象，媒体公司根据领域如“播客”（管理播客发布及其主持人的团队和系统）、“艺术家”（管理艺术家入职和支付的团队和系统）等，划分其运营以及支持运营的系统和团队。数据网格主张，分析数据的所有权和服务应尊重这些领域。例如，管理“播客”的团队在提供发布播客的API的同时，也应负责提供随时间变化的“已发布播客”的历史数据，以及其他事实，如随时间变化的“听众人数”。有关此原则的更深入探讨，请参见面向领域的数据分解和所有权。</p>
<h3><a id="%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%EF%BC%9A%E9%9D%A2%E5%90%91%E9%A2%86%E5%9F%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AE%A1%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑架构：面向领域的数据和计算</h3>
<p>为了促进这种分解，我们需要构建一个按领域排列分析数据的架构。在这个架构中，领域对组织的其余部分的接口不仅包括运营能力，还包括领域所服务的分析数据的访问。例如，“播客”领域提供了“创建新的播客剧集”的运营API，但也提供了检索“过去<n>个月所有播客剧集数据”的分析数据端点。这意味着架构必须消除任何摩擦或耦合，让领域能够服务其分析数据，并独立于其他领域发布计算数据的代码。为了实现扩展，架构必须支持领域团队在其运营或分析数据系统的发布和部署方面的自主性。</p>
<p>以下示例展示了面向领域数据所有权的原则。这些图表仅为逻辑表示和示例性展示，并不旨在完整。</p>
<p>每个领域可以公开一个或多个运营API，以及一个或多个分析数据端点。<br />
<img src="media/17117904284058/17117909976695.jpg" alt="" /></p>
<p>图4：符号表示：领域、其分析数据和运营能力</p>
<p>自然地，每个领域可能依赖于其他领域的运营和分析数据端点。在以下示例中，“播客”领域消费了来自“用户”领域的“用户更新”分析数据，以便通过其“播客听众人口统计”数据集提供播客听众的人口统计图像。<br />
<img src="media/17117904284058/17117910105411.jpg" alt="" /></p>
<p>图5：示例：领域导向的分析数据所有权以及运营能力的示例</p>
<p>注意：在示例中，我使用了命令式语言来访问运营数据或能力，例如“支付给艺术家”。这仅仅是为了强调访问运营数据与分析数据意图之间的区别。我确实认识到，在实践中，运营API是通过更声明式的接口实现的，例如访问RESTful资源或GraphQL查询。</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E5%8D%B3%E4%BA%A7%E5%93%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据即产品</h2>
<p>现有分析数据架构面临的挑战之一是发现、理解、信任以及最终使用高质量数据的高摩擦和成本。如果不加以解决，随着提供数据的领域（即数据的去中心化）数量和团队的增加，这个问题只会加剧。这将是我们第一个原则——去中心化——的后果。数据即产品原则旨在解决数据质量和长期存在的数据孤岛问题；或者正如Gartner所称的“暗数据”——“组织在正常业务活动中收集、处理和存储的信息资产，但通常未能用于其他目的”。领域提供的分析数据必须被视为一种产品，而该数据的使用者应被视为客户——快乐且满意的客户。</p>
<p>原始文章列举了一系列能力，包括可发现性、安全性、可探索性、可理解性、可信度等，这些都是数据网格实施应支持的能力，以使领域数据被视为一种产品。文章还详细介绍了组织必须引入的角色，如领域数据产品所有者，负责确保数据作为产品交付的客观措施。这些措施包括数据质量、数据消费的缩短前置时间，以及通过净推荐者得分等方式提高数据用户满意度。领域数据产品所有者必须深刻了解数据使用者是谁、他们如何使用数据，以及他们舒适地消费数据的本地方法是什么。对数据使用者如此亲密的了解，导致了满足他们需求的数据产品界面的设计。实际上，对于网格上的大多数数据产品，有一些传统的人物角色，他们有独特的工具和期望，数据分析师和数据科学家。所有数据产品都可以开发标准化的接口来支持他们。数据使用者和产品所有者之间的对话是建立数据产品界面的必要环节。</p>
<p>每个领域将包括数据产品开发人员角色，负责构建、维护和服务领域的数据产品。数据产品开发人员将与领域中的其他开发人员一起工作。每个领域团队可能提供一个或多个数据产品。也可以组建新的团队来服务那些不适合现有运营领域的数据产品。</p>
<p>注意：与过去的范式相比，这是一个倒置的责任模型。数据质量的责任尽可能地向上游转移，接近数据的来源。</p>
<h3><a id="%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%BA%A7%E5%93%81%E4%BD%9C%E4%B8%BA%E6%9E%B6%E6%9E%84%E9%87%8F%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑架构：数据产品作为架构量子</h3>
<p>为了支持领域可以自主服务或消费的数据即产品，数据网格引入了数据产品作为其架构量子的概念。架构量子，如进化架构所定义，是架构中可以独立部署的最小单元，具有高功能内聚性，并包括其功能所需的所有结构元素。</p>
<p>数据产品是网格上的节点，封装了其功能所需的三个结构组件，作为产品提供对领域分析数据的访问。</p>
<ul>
<li>代码：包括(a) 负责消费、转换和服务上游数据的数据管道代码——从领域的运营系统或上游数据产品接收到的数据；(b) 提供数据访问的API代码，语义和语法模式，可观察性指标和其他元数据；(c) 执行访问控制策略、合规性、来源等特征的代码。</li>
<li>数据和元数据：嗯，这就是我们所有人都在寻求的，以多语言形式存在的底层分析和历史数据。根据领域数据的性质和消费模型，数据可以作为事件、批处理文件、关系表、图表等提供，同时保持相同的语义。为了使数据可用，有一套相关的元数据，包括数据计算文档、语义和语法声明、质量指标等；数据固有的元数据，例如其语义定义，以及传达计算治理用于实现预期行为的特征的元数据，例如访问控制策略。</li>
<li>基础设施：基础设施组件支持构建、部署和运行数据产品的代码，以及对大数据和元数据的存储和访问。<br />
<img src="media/17117904284058/17117912145754.jpg" alt="" /></li>
</ul>
<p>图6：数据产品组件作为一个架构量子</p>
<p>以下示例建立在前一节的基础上，展示了数据产品作为架构量子。图表仅包括示例内容，不旨在完整或包含所有设计和实施细节。虽然这仍然是一个逻辑表示，但它更接近物理实现。<br />
<img src="media/17117904284058/17117912273416.jpg" alt="" /></p>
<p>图7：符号表示：领域、其（分析）数据产品和运营系统<br />
<img src="media/17117904284058/17117912365436.jpg" alt="" /></p>
<p>图8：数据产品服务面向领域的分析数据</p>
<p>注意：数据网格模型与过去的范式不同，过去的范式中管道（代码）作为独立组件从它们产生的数据中管理；而且基础设施，如仓库实例或湖泊存储账户，通常在许多数据集之间共享。数据产品是所有组件——代码、数据和基础设施——在领域有界上下文的粒度上的组合。</p>
<h2><a id="%E8%87%AA%E5%8A%A9%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自助式数据平台</h2>
<p>正如你所想象的，要构建、部署、执行、监控和访问一个简单的六边形——一个数据产品——需要配置和运行相当多的基础设施；配置这些基础设施所需的技能是专业的，并且在每个领域都难以复制。最重要的是，团队能够自主拥有其数据产品的唯一途径是访问一个高级抽象的基础设施，该基础设施消除了配置和管理数据产品生命周期的复杂性和摩擦。这就呼唤了一个新的原则，即自助式数据基础设施作为平台，以实现领域自治。</p>
<p>数据平台可以被视为已经存在的用于运行和监控服务的交付平台的扩展。然而，如今运营数据产品的底层技术栈与服务的交付平台看起来非常不同。这仅仅是由于大数据技术栈与运营平台的分歧。例如，领域团队可能将其服务部署为Docker容器，交付平台使用Kubernetes进行编排；然而，相邻的数据产品可能正在Databricks集群上以Spark作业的形式运行其管道代码。这就要求配置和连接两套非常不同的基础设施，而在数据网格之前，并不要求这种级别的互操作性和互联性。我个人的希望是，我们开始看到运营和数据基础设施的融合，这在有意义的地方是可能的。例如，也许在同一个编排系统上运行Spark，例如Kubernetes。</p>
<p>实际上，为了使分析数据产品开发对通用开发者可访问，对领域现有的开发者配置来说，自助式平台需要提供一类新工具和接口，除了简化配置。自助式数据平台必须创建支持领域数据产品开发者以较少的专业知识创建、维护和运行数据产品的工具；自助式基础设施必须包括降低当前构建数据产品所需的成本和专业化的能力。原始文档包括了自助式数据平台提供的一系列能力，包括可扩展的多语言数据存储、数据产品模式、数据管道声明和编排、数据产品血统、计算和数据本地性等。</p>
<h3><a id="%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%EF%BC%9A%E5%A4%9A%E5%B9%B3%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑架构：多平面数据平台</h3>
<p>自助式平台的能力分为多个类别或平面，如模型中所称。注意：平面代表了一种存在层次——集成但独立。类似于物理和意识平面，或网络中的控制和数据平面。平面既不是层，也不意味着强烈的层次访问模型。<br />
<img src="media/17117904284058/17117914607286.jpg" alt="" /></p>
<p>图9：符号表示：平台平面通过自助式接口提供一系列相关能力</p>
<p>自助式平台可以有多个平面，每个平面为不同配置的用户提供服务。在以下示例中，列出了三个不同的数据平台平面：</p>
<ul>
<li>数据基础设施配置平面：支持配置运行数据产品组件和产品网格所需的底层基础设施。这包括配置分布式文件存储、存储帐户、访问控制管理系统、运行数据产品内部代码的编排、在数据产品图上配置分布式查询引擎等。我预计只有其他数据平台平面或仅高级数据产品开发者直接使用此接口。这是一个相当低级别的数据基础设施生命周期管理平面。</li>
<li>数据产品开发者体验平面：这是典型数据产品开发者使用的主要接口。此接口抽象了许多支持数据产品开发者工作流程的复杂性。它比“配置平面”提供了更高级别的抽象。它使用简单的声明式接口来管理数据产品的生命周期。它自动实现了作为一组标准和全球约定定义的跨切面关注点，应用于所有数据产品及其接口。</li>
<li>数据网格监管平面：有一些能力最好在网格级别——连接的数据产品图——全局提供。虽然每个接口的实现可能依赖于单个数据产品的能力，但在网格级别提供这些能力更为方便。例如，发现特定用例的数据产品的能力，最好通过搜索或浏览数据产品网格来提供；或者通过执行可以在网格上的多个数据产品上操作的数据语义查询来关联多个数据产品以创建更高阶的洞察力，这是最佳提供的。<br />
以下模型仅是示例性的，并不旨在完整。虽然平面的层次结构是可取的，但下面并没有严格的分层含义。<br />
<img src="media/17117904284058/17117914960065.jpg" alt="" /></li>
</ul>
<p>图10：自助式数据平台的多个平面 *DP代表数据产品</p>
<h2><a id="%E8%81%94%E9%82%A6%E8%AE%A1%E7%AE%97%E6%B2%BB%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>联邦计算治理</h2>
<p>如您所见，数据网格遵循分布式系统架构；一系列独立的数据产品，具有独立的生命周期，由可能是独立的团队构建和部署。然而，对于大多数用例来说，为了获得更高阶数据集、洞察力或机器智能等形式的价值，需要这些独立的数据产品进行互操作；能够关联它们，创建联合，找到交集，或在大规模上对它们执行其他图形或集合操作。为了使这些操作成为可能，数据网格实施需要一个治理模型，该模型拥抱去中心化和领域自主权，通过全球标准化实现互操作性，动态拓扑，最重要的是平台自动执行决策。我称这为联合计算治理。这是一个由领域数据产品所有者和数据平台产品所有者组成的联邦决策模型，具有自治权和领域本地决策权，同时创建并遵守一套全球规则——适用于所有数据产品及其接口的规则——以确保健康和互操作的生态系统。这个组织的任务很艰巨：在集中化和去中心化之间保持平衡；哪些决策需要本地化到每个领域，哪些决策应该为所有领域全球制定。最终，全球决策有一个目的，即通过数据产品的发现和组合创造互操作性和复合网络效应。</p>
<p>数据网格中的治理优先级与传统的分析数据管理系统的治理不同。尽管它们都最终旨在从数据中获取价值，但传统的数据治理试图通过集中决策制定来实现这一目标，并建立数据的全球规范表示，对变化的支持最小。相比之下，数据网格的联合计算治理拥抱变化和多种解释性背景。</p>
<blockquote>
<p>将系统置于恒定的紧身衣中可能会导致脆弱性的演变。<br />
-- C.S. Holling，生态学家</p>
</blockquote>
<h3><a id="%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%BD%91%E6%A0%BC%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%9A%84%E8%AE%A1%E7%AE%97%E6%94%BF%E7%AD%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>逻辑架构：网格中嵌入的计算政策</h3>
<p>支持性的组织结构、激励模型和架构是联合治理模型运作所必需的：在全球范围内为互操作性达成决策和标准，同时尊重本地领域的自治，并有效地实施全球政策。<br />
<img src="media/17117904284058/17117917044528.jpg" alt="" /></p>
<p>图11：符号表示：联合计算治理模型</p>
<p>如前所述，在全球范围内应该标准化、实施和强制执行哪些内容，以及哪些内容应该留给领域自行决定，这是一种艺术。例如，领域数据模型是一个应该本地化到最熟悉它的领域的关注点。例如，'播客听众'数据模型的语义和语法定义必须留给'播客领域'团队。然而，相比之下，如何识别'播客听众'的决定是一个全球关注点。播客听众是'用户'人口的一员——其上游有界上下文——他可以跨越领域的边界，并在其他领域如'用户播放流'中被发现。统一识别允许关联关于既是'播客听众'又是'流媒体听众'的'用户'的信息。</p>
<p>以下是数据网格治理模型中涉及的元素的示例。这不是一个全面的示例，只是展示了在全球层面相关的关注点。<br />
<img src="media/17117904284058/17117917140620.jpg" alt="" /></p>
<p>图12：联合计算治理的元素示例：团队、激励、自动化实施和数据网格的全球标准化方面</p>
<p>许多数据网格治理之前的实践，作为集中功能，不再适用于数据网格范式。例如，过去强调认证黄金数据集——经过集中的质量控制和认证过程并被标记为可信的——作为治理的中心功能，现在不再相关。这源于在以前的数据管理范式中，数据——无论质量和格式如何——从运营领域的数据库中提取出来，然后集中存储在需要一个集中团队对其应用清洗、协调和加密过程的数据仓库或数据湖中；通常在集中治理小组的管理下。数据网格完全去中心化了这个关注点。领域数据集只有在领域内部根据预期的数据产品质量指标和全球标准化规则经过质量保证过程后，才能成为数据产品。领域数据产品所有者最有能力决定如何衡量他们领域的数据质量，因为他们了解首先产生数据的领域运营的细节。尽管有这样的本地化决策和自治，但他们需要遵守全球联合治理团队定义的质量和SLO规范的建模，并由平台自动化。</p>
<p>以下表格显示了集中式（数据湖、数据仓库）数据治理模型与数据网格之间的对比。<br />
在数据网格治理方面，与传统的集中式数据治理相比，有几个关键的差异和转变。以下是数据网格治理的一些主要方面，以及它们如何与传统的数据治理相比较：</p>
<ol>
<li>
<p><strong>团队结构</strong>：</p>
<ul>
<li>传统的数据治理通常由一个集中的团队负责，而数据网格治理则采用联合团队的模式，这个团队由各个领域的代表组成。这样的结构更强调领域自治和领域间的协作。</li>
</ul>
</li>
<li>
<p><strong>数据质量</strong>：</p>
<ul>
<li>集中式治理模式下，团队负责数据质量的维护。而在数据网格中，团队负责定义如何建模和衡量质量，而不是直接负责数据质量本身。</li>
</ul>
</li>
<li>
<p><strong>数据安全</strong>：</p>
<ul>
<li>在集中式治理中，团队负责整体的数据安全。而在数据网格中，团队负责定义数据安全的不同方面，例如数据的敏感性级别，以便平台能够自动构建和监控。</li>
</ul>
</li>
<li>
<p><strong>法规遵从</strong>：</p>
<ul>
<li>传统的数据治理模式要求团队负责遵守所有相关法规。在数据网格中，团队负责定义法规要求，以便平台能够自动构建和监控合规性。</li>
</ul>
</li>
<li>
<p><strong>数据管理</strong>：</p>
<ul>
<li>集中式治理模式下，数据的保管权集中在一个团队手中。而在数据网格中，数据的保管权由各个领域共同承担，实行联合保管。</li>
</ul>
</li>
<li>
<p><strong>数据模型</strong>：</p>
<ul>
<li>集中式治理模式下，团队负责全局规范的数据建模。而在数据网格中，团队负责对多义性数据元素进行建模，这些数据元素跨越多个领域的边界。</li>
</ul>
</li>
<li>
<p><strong>技术使用</strong>：</p>
<ul>
<li>传统的数据治理通常依赖于集中式技术，如单一的数据湖或数据仓库。而在数据网格中，每个领域使用自助服务平台技术，以支持其独特的需求和工作流程。</li>
</ul>
</li>
<li>
<p><strong>成功衡量</strong>：</p>
<ul>
<li>在集中式治理中，成功的衡量通常基于治理数据的数量或体积。而在数据网格中，成功的衡量基于网络效应——即表示网格上数据消费的连接数量。</li>
</ul>
</li>
<li>
<p><strong>错误处理</strong>：</p>
<ul>
<li>传统的数据治理依赖于人工干预的手动流程来预防错误。而在数据网格中，平台通过自动化流程来检测错误并实现恢复。</li>
</ul>
</li>
</ol>
<p>数据网格治理的目标是支持网格的有效运作，同时适应不断变化和动态拓扑结构的网格。这种治理模式鼓励领域间的协作和自治，通过自动化和标准化来提高效率和互操作性，从而实现数据的最大价值。<br />
<img src="media/17117904284058/17117918380731.jpg" alt="" /></p>
<h2><a id="%E5%9B%9B%E4%B8%AA%E5%8E%9F%E5%88%99%E6%80%BB%E7%BB%93%E5%92%8C%E9%AB%98%E7%BA%A7%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四个原则总结和高级逻辑架构</h2>
<p>让我们总结一下，我们讨论了支撑数据网格的四个原则：</p>
<ol>
<li>
<p><strong>面向领域的分散式数据所有权和架构</strong>：这一原则强调数据应该根据其业务领域进行管理和组织，每个领域都有其负责人和团队，他们对数据的收集、存储、处理和分发负有完全的责任。这种分散化的方法有助于提高数据的可访问性和可维护性，同时促进跨领域的协作和数据共享。</p>
</li>
<li>
<p><strong>数据即产品</strong>：将数据视为一种产品，意味着我们需要关注数据的质量、可用性和用户体验。数据产品化鼓励团队像对待任何其他商业产品一样对待数据，包括对其进行品牌化、营销和持续改进。</p>
</li>
<li>
<p><strong>自助式数据基础设施作为平台</strong>：这一原则提倡建立一个平台，使得用户能够轻松地发现、访问和使用数据，而无需深入了解底层技术和复杂的数据处理流程。这种基础设施的自助服务特性，可以降低技术门槛，提高数据的可消费性。</p>
</li>
<li>
<p><strong>联合计算治理</strong>：在数据网格中，计算治理是分散的，但是通过联合的方式进行协调和管理。这意味着不同的数据领域可以独立地进行计算和分析，同时保持整体的数据一致性和合规性。这种治理模式有助于提高数据处理的效率和响应速度，同时确保数据的安全和隐私。</p>
</li>
</ol>
<p>这些原则共同构成了数据网格的高级逻辑架构，它们指导着数据网格的设计和实施，旨在实现数据管理和分析的现代化，支持快速决策、创新和业务增长。通过这些原则，组织可以更好地利用数据资源，构建一个灵活、可扩展且可持续发展的数据生态系统，以适应不断变化的技术和市场需求。</p>
<p>这些原则推动了一个逻辑架构模型的发展，该模型在将分析数据和操作数据更紧密地结合在同一个领域下的同时，尊重它们的基础技术差异。这些差异包括分析数据可能托管的位置、处理操作性与分析服务的不同计算技术、查询和访问数据的不同方式等。</p>
<p>在这个逻辑架构模型中，以下几个关键点被特别强调：</p>
<ol>
<li>
<p><strong>领域驱动的数据集成</strong>：</p>
<ul>
<li>数据不是简单地聚集在一起，而是根据业务领域进行组织和集成。领域团队负责管理和维护与其领域相关的数据，无论是操作数据还是分析数据。这种集成方式确保了数据的上下文相关性和业务连贯性。</li>
</ul>
</li>
<li>
<p><strong>技术异构性的管理</strong>：</p>
<ul>
<li>尽管操作数据和分析数据在同一个领域内被管理，但它们可能需要不同的技术栈和平台来最有效地处理和分析。逻辑架构模型允许这种异构性，同时提供了必要的抽象和接口，以确保不同技术之间的兼容性和互操作性。</li>
</ul>
</li>
<li>
<p><strong>数据的可访问性和治理</strong>：</p>
<ul>
<li>逻辑架构模型提供了一种机制，使得数据消费者可以轻松地发现、查询和访问所需的数据。同时，它也确保了数据治理的一致性，包括安全性、合规性和数据质量控制，无论数据是操作性的还是分析性的。</li>
</ul>
</li>
<li>
<p><strong>自动化和自助服务</strong>：</p>
<ul>
<li>为了降低技术复杂性并提高效率，逻辑架构模型鼓励使用自动化工具和服务，以及自助服务平台。这些工具和平台使得领域团队能够独立地管理和优化他们的数据产品，同时也支持数据消费者自助获取和使用数据。</li>
</ul>
</li>
</ol>
<p>通过这种逻辑架构模型，数据网格不仅能够弥合操作数据和分析数据之间的鸿沟，还能够充分利用各自的技术优势，为组织提供更加灵活、高效和创新的数据管理解决方案。这种方法有助于构建一个可持续发展的数据生态系统，支持组织在快速变化的市场中保持竞争力。</p>
<p><img src="media/17117904284058/17117921263102.jpg" alt="" /></p>
<p>确实，通过前面的讨论，我们已经建立了一个共同的语言框架和逻辑心智模型，这将帮助我们共同推进数据网格的组件蓝图的详细规划，包括数据产品、平台以及所需的标准化等方面。</p>
<ol>
<li>
<p><strong>数据产品（Data Product）</strong>：</p>
<ul>
<li>数据产品是数据网格中的核心构建块，它封装了数据内容、相关的元数据以及为数据提供服务的代码。数据产品应该被设计成易于发现、理解和使用，同时保证数据的质量和安全性。数据产品的创建、维护和分发需要遵循一系列标准化的流程和接口，以确保跨领域的一致性和互操作性。</li>
</ul>
</li>
<li>
<p><strong>平台（Platform）</strong>：</p>
<ul>
<li>数据平台提供了支持数据产品开发、部署、运行和监管的基础设施和服务。这包括数据存储、计算资源、数据处理管道、API服务等。平台应该提供自助式的服务，使领域团队能够高效地管理和优化他们的数据产品，同时降低技术复杂性和提高自动化程度。</li>
</ul>
</li>
<li>
<p><strong>标准化（Standardizations）</strong>：</p>
<ul>
<li>为了实现数据网格中的互操作性和一致性，需要制定一系列全球标准和约定。这些标准化包括数据模型、数据安全级别、数据质量指标、API设计原则等。标准化不仅有助于简化数据产品的设计和实现，还能够提高数据的可发现性和可访问性。</li>
</ul>
</li>
</ol>
<p>通过这些组件的详细规划和实施，我们可以确保数据网格能够有效地支持组织的数据战略，促进数据驱动的决策和创新。这种基于领域的、产品化的数据管理方法有助于打破数据孤岛，提高数据的流动性和价值，最终推动组织的整体发展和竞争力。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2024/03/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='datamesh.html'>Data Mesh</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="the-c4-model-for-visualising-s.html">
                
                  <h1>The C4 model for visualising software architecture 用于可视化软件架构的 C4 模型</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="the-c4-model%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>The C4 model 定义</h2>
<ol>
<li>A set of hierarchical abstractions (software systems, containers, components, and code).</li>
</ol>
<blockquote>
<p>翻译：一组分层抽象（软件系统、容器、组件和代码）。</p>
</blockquote>
<ol start="2">
<li>A set of hierarchical diagrams (system context, containers, components, and code).</li>
</ol>
<blockquote>
<p>翻译：一组分层图（系统上下文、容器、组件和代码）。</p>
</blockquote>
<ol start="3">
<li>Notation independent.</li>
</ol>
<blockquote>
<p>翻译：符号独立。</p>
</blockquote>
<ol start="4">
<li>Tooling independent.</li>
</ol>
<blockquote>
<p>翻译：工具独立。</p>
</blockquote>
<h2><a id="uses-and-benefits%E7%94%A8%E9%80%94%E5%92%8C%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Uses and benefits 用途和好处</h2>
<p>The C4 model is an easy to learn, developer friendly approach to software architecture diagramming. Good software architecture diagrams assist with communication inside/outside of software development/product teams, efficient onboarding of new staff, architecture reviews/evaluations, risk identification (e.g. risk-storming), threat modelling, etc.</p>
<blockquote>
<p>翻译： C4 模型是一种易于学习、开发人员友好的软件架构图绘制方法。良好的软件架构图有助于软件开发/产品团队内部/外部的沟通、新员工的高效入职、架构审查/评估、风险识别（例如风险风暴）、威胁建模等。</p>
</blockquote>
<h2><a id="introduction%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction 介绍</h2>
<p>Ask somebody in the building industry to visually communicate the architecture of a building and you'll be presented with site plans, floor plans, elevation views, cross-section views and detail drawings. In contrast, ask a software developer to communicate the software architecture of a software system using diagrams and you'll likely get a confused mess of boxes and lines ... inconsistent notation (colour coding, shapes, line styles, etc), ambiguous naming, unlabelled relationships, generic terminology, missing technology choices, mixed abstractions, etc.</p>
<blockquote>
<p>翻译：  请建筑行业的某个人直观地传达建筑物的建筑结构，您将看到场地平面图、平面图、立面图、横截面图和详细图纸。相比之下，让软件开发人员使用图表来传达软件系统的软件架构，您可能会得到一堆混乱的方框和线条......不一致的符号（颜色编码、形状、线条样式等）、模棱两可的命名、未标记的关系、通用术语、缺少技术选择、混合抽象等。</p>
</blockquote>
<p>As an industry, we do have the Unified Modeling Language (UML), ArchiMate and SysML, but asking whether these provide an effective way to communicate software architecture is often irrelevant because many teams have already thrown them out in favour of much simpler &quot;boxes and lines&quot; diagrams. Abandoning these modelling languages is one thing but, perhaps in the race for agility, many software development teams have lost the ability to communicate visually.</p>
<blockquote>
<p>翻译： 作为一个行业，我们确实有统一建模语言（UML）、ArchiMate和SysML，但要问它们是否提供了一种有效的方法来传达软件架构通常是无关紧要的，因为许多团队已经抛弃了它们，转而使用更简单的“方框和线”图。放弃这些建模语言是一回事，但也许在敏捷性的竞赛中，许多软件开发团队已经失去了可视化通信的能力。</p>
</blockquote>
<h3><a id="maps-of-your-code%E4%BB%A3%E7%A0%81%E6%98%A0%E5%B0%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maps of your code 代码映射</h3>
<p>The C4 model was created as a way to help software development teams describe and communicate software architecture, both during up-front design sessions and when retrospectively documenting an existing codebase. It's a way to create maps of your code, at various levels of detail, in the same way you would use something like Google Maps to zoom in and out of an area you are interested in.</p>
<blockquote>
<p>翻译： C4 模型的创建是为了帮助软件开发团队描述和交流软件架构，无论是在前期设计会议期间还是在回顾性地记录现有代码库时。这是一种在各种细节级别上创建代码地图的方法，就像你使用谷歌地图之类的东西来放大和缩小你感兴趣的区域一样。</p>
</blockquote>
<p>The C4 model is an &quot;abstraction-first&quot; approach to diagramming software architecture, based upon abstractions that reflect how software architects and developers think about and build software. The small set of abstractions and diagram types makes the C4 model easy to learn and use. Please note that you don't need to use all 4 levels of diagram; only those that add value - the System Context and Container diagrams are sufficient for many software development teams.</p>
<blockquote>
<p>翻译：C4 模型是一种“抽象优先”的软件架构图示方法，它基于反映软件架构师和开发人员如何思考和构建软件的抽象。一小部分抽象和图表类型使 C4 模型易于学习和使用。请注意，您不需要使用所有 4 个级别的图表;只有那些能增加价值的东西 - 系统上下文和容器图对于许多软件开发团队来说就足够了。</p>
</blockquote>
<p>Different levels of zoom allow you to tell different stories to different audiences.<br />
不同级别的缩放允许您向不同的受众讲述不同的故事。</p>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105955272098.jpg" alt="" /></p>
<h2><a id="abstractions%E6%8A%BD%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Abstractions 抽象</h2>
<p>In order to create these maps of your code, we first need a common set of abstractions to create a ubiquitous language that we can use to describe the static structure of a software system. A software system is made up of one or more containers (applications and data stores), each of which contains one or more components, which in turn are implemented by one or more code elements (classes, interfaces, objects, functions, etc). And people may use the software systems that we build.</p>
<blockquote>
<p>翻译： 为了创建这些代码映射，我们首先需要一组通用的抽象来创建一种通用语言，我们可以用它来描述软件系统的静态结构。软件系统由一个或多个容器（应用程序和数据存储）组成，每个容器都包含一个或多个组件，而这些组件又由一个或多个代码元素（类、接口、对象、函数等）实现。人们可能会使用我们构建的软件系统。</p>
</blockquote>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105968643283.jpg" alt="" /></p>
<blockquote>
</blockquote>
<h3><a id="person%E4%BA%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Person 人</h3>
<p>A person represents one of the human users of your software system (e.g. actors, roles, personas, etc).</p>
<blockquote>
<p>翻译： 一个人代表您的软件系统的人类用户之一（例如演员、角色、角色等）。</p>
</blockquote>
<h3><a id="software-system%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Software System 软件系统</h3>
<p>A software system is the highest level of abstraction and describes something that delivers value to its users, whether they are human or not. This includes the software system you are modelling, and the other software systems upon which your software system depends (or vice versa).</p>
<blockquote>
<p>翻译： 软件系统是最高级别的抽象，它描述了为其用户提供价值的东西，无论他们是否是人类。这包括您正在建模的软件系统，以及您的软件系统所依赖的其他软件系统（反之亦然）。</p>
</blockquote>
<p>Unfortunately the term &quot;software system&quot; is the hardest of the C4 model abstractions to define, and this isn't helped by the fact that each organisation will also have their own terminology for describing the same thing, typically using terms such as &quot;application&quot;, &quot;product&quot;, &quot;service&quot;, etc. One way to think about it is that a software system is something a single software development team is building, owns, has responsibility for, and can see the internal implementation details of. Perhaps the code for that software system resides in a single source code repository, and anybody on the team is entitled to modify it. In many cases, the boundary of a software system will correspond to the boundary of a single team. It may also be the case that everything inside the boundary of a software system is deployed at the same time.</p>
<blockquote>
<p>翻译： 不幸的是，“软件系统”这个术语是 C4 模型抽象中最难定义的，而且每个组织都有自己的术语来描述同一事物，通常使用“应用程序”、“产品”、“服务”等术语。一种思考方式是，软件系统是一个软件开发团队正在构建、拥有、负责并可以看到内部实现细节的东西。也许该软件系统的代码驻留在单个源代码存储库中，团队中的任何人都有权修改它。在许多情况下，软件系统的边界将对应于单个团队的边界。也可能是同时部署软件系统边界内的所有内容。</p>
</blockquote>
<h3><a id="container-applications-and-data-stores%E5%AE%B9%E5%99%A8%EF%BC%88%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Container (applications and data stores) 容器（应用程序和数据存储）</h3>
<p>Not Docker! In the C4 model, a container represents an application or a data store. A container is something that needs to be running in order for the overall software system to work. In real terms, a container is something like:</p>
<blockquote>
<p>翻译： 不是Docker！在 C4 模型中，容器表示应用程序或数据存储。容器是整个软件系统工作所需要运行的东西。实际上，容器是这样的：</p>
</blockquote>
<h4><a id="server-side-web-application" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server-side web application:</h4>
<p>A Java EE web application running on Apache Tomcat, an ASP.NET MVC application running on Microsoft IIS, a Ruby on Rails application running on WEBrick, a Node.js application, etc.</p>
<blockquote>
<p>翻译： 服务器端 Web 应用程序：运行在 Apache Tomcat 上的 Java EE Web 应用程序、运行在 Microsoft IIS 上的 ASP.NET MVC 应用程序、运行在 WEBrick 上的 Ruby on Rails 应用程序、Node.js 应用程序等。</p>
</blockquote>
<h4><a id="client-side-web-application" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client-side web application:</h4>
<p>A JavaScript application running in a web browser using Angular, Backbone.JS, jQuery, etc.</p>
<blockquote>
<p>翻译： 客户端 Web 应用程序：使用 Angular、Backbone.JS、jQuery 等在 Web 浏览器中运行的 JavaScript 应用程序。</p>
</blockquote>
<h4><a id="client-side-desktop-application" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client-side desktop application:</h4>
<p>A Windows desktop application written using WPF, an OS X desktop application written using Objective-C, a cross-platform desktop application written using JavaFX, etc.</p>
<blockquote>
<p>翻译： 客户端桌面应用程序：使用 WPF 编写的 Windows 桌面应用程序、使用 Objective-C 编写的 OS X 桌面应用程序、使用 JavaFX 编写的跨平台桌面应用程序等。</p>
</blockquote>
<h4><a id="mobile-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mobile app:</h4>
<p>An Apple iOS app, an Android app, a Microsoft Windows Phone app, etc.</p>
<blockquote>
<p>翻译： 移动应用程序：Apple iOS 应用程序、Android 应用程序、Microsoft Windows Phone 应用程序等。</p>
</blockquote>
<h4><a id="server-side-console-application" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server-side console application:</h4>
<p>A standalone (e.g. &quot;public static void main&quot;) application, a batch process, etc.</p>
<blockquote>
<p>翻译： 服务器端控制台应用程序：独立（例如“public static void main”）应用程序、批处理等。</p>
</blockquote>
<h4><a id="serverless-function" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serverless function:</h4>
<p>A single serverless function (e.g. Amazon Lambda, Azure Function, etc).</p>
<blockquote>
<p>翻译： 无服务器函数：单个无服务器函数（例如 Amazon Lambda、Azure 函数等）。</p>
</blockquote>
<h4><a id="database" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Database:</h4>
<p>A schema or database in a relational database management system, document store, graph database, etc such as MySQL, Microsoft SQL Server, Oracle Database, MongoDB, Riak, Cassandra, Neo4j, etc.</p>
<blockquote>
<p>翻译： 数据库：关系数据库管理系统、文档存储、图形数据库等中的模式或数据库，如MySQL、Microsoft SQL Server、Oracle Database、MongoDB、Riak、Cassandra、Neo4j等。</p>
</blockquote>
<h4><a id="blob-or-content-store" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blob or content store:</h4>
<p>A blob store (e.g. Amazon S3, Microsoft Azure Blob Storage, etc) or content delivery network (e.g. Akamai, Amazon CloudFront, etc).</p>
<blockquote>
<p>翻译： 对象或内容存储：对象存储（例如 Amazon S3、Microsoft Azure 对象存储等）或内容分发网络（例如 Akamai、Amazon CloudFront 等）。</p>
</blockquote>
<h4><a id="file-system" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>File system:</h4>
<p>A full local file system or a portion of a larger networked file system (e.g. SAN, NAS, etc).</p>
<blockquote>
<p>翻译： 文件系统：完整的本地文件系统或较大的网络文件系统（例如 SAN、NAS 等）的一部分。</p>
</blockquote>
<h4><a id="shell-script" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shell script:</h4>
<p>A single shell script written in Bash, etc.</p>
<blockquote>
<p>翻译： Shell 脚本：用 Bash 等语言编写的单个 shell 脚本。<br />
etc</p>
</blockquote>
<h3><a id="component%E7%BB%84%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Component 组件</h3>
<p>The word &quot;component&quot; is a hugely overloaded term in the software development industry, but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface. If you're using a language like Java or C#, the simplest way to think of a component is that it's a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.</p>
<blockquote>
<p>翻译： “组件”这个词在软件开发行业中是一个非常过载的术语，但在这种情况下，组件是封装在定义良好的接口后面的一组相关功能。如果您使用的是 Java 或 C# 等语言，那么考虑组件的最简单方法是它是接口后面的实现类的集合。诸如如何打包这些组件（例如，一个组件与每个 JAR 文件、DLL、共享库等的多个组件）等方面是一个单独的正交问题。</p>
</blockquote>
<p>An important point to note here is that all components inside a container typically execute in the same process space. In the C4 model, components are not separately deployable units.</p>
<blockquote>
<p>翻译： 这里需要注意的重要一点是，容器内的所有组件通常在同一个进程空间中执行。在 C4 模型中，组件不是可单独部署的单元。</p>
</blockquote>
<h2><a id="1-system-context-diagram%E7%B3%BB%E7%BB%9F%E4%B8%8A%E4%B8%8B%E6%96%87%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. System Context diagram 系统上下文图</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105958584901.jpg" alt="" /></p>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105959088372.jpg" alt="" /></p>
<p>A System Context diagram is a good starting point for diagramming and documenting a software system, allowing you to step back and see the big picture. Draw a diagram showing your system as a box in the centre, surrounded by its users and the other systems that it interacts with.</p>
<blockquote>
<p>翻译：系统上下文图是绘制和记录软件系统的良好起点，可让您退后一步，纵观全局。绘制一张图表，将您的系统显示为中间的一个框，周围环绕着其用户和与之交互的其他系统。</p>
</blockquote>
<p>Detail isn't important here as this is your zoomed out view showing a big picture of the system landscape. The focus should be on people (actors, roles, personas, etc) and software systems rather than technologies, protocols and other low-level details. It's the sort of diagram that you could show to non-technical people.</p>
<blockquote>
<p>翻译：细节在这里并不重要，因为这是您的缩小视图，显示了系统环境的大图。重点应该放在人（参与者、角色、角色等）和软件系统上，而不是技术、协议和其他低级细节上。这是您可以向非技术人员展示的那种图表。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>A single software system.</p>
<blockquote>
<p>翻译：范围：单个软件系统。</p>
</blockquote>
<h3><a id="primary-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary elements:</h3>
<p>The software system in scope.</p>
<blockquote>
<p>翻译：主要元素：范围内的软件系统。</p>
</blockquote>
<h3><a id="supporting-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supporting elements:</h3>
<p>People (e.g. users, actors, roles, or personas) and software systems (external dependencies) that are directly connected to the software system in scope. Typically these other software systems sit outside the scope or boundary of your own software system, and you don't have responsibility or ownership of them.</p>
<blockquote>
<p>翻译：支持元素：直接连接到范围内软件系统的人员（例如用户、参与者、角色或角色）和软件系统（外部依赖关系）。通常，这些其他软件系统位于您自己的软件系统的范围或边界之外，您对它们没有责任或所有权。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Everybody, both technical and non-technical people, inside and outside of the software development team.</p>
<blockquote>
<p>翻译：目标受众：软件开发团队内部和外部的每个人，包括技术人员和非技术人员。</p>
</blockquote>
<h3><a id="recommended-for-most-teams" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recommended for most teams:</h3>
<p>Yes.</p>
<blockquote>
<p>翻译： 建议大多数团队：是的。</p>
</blockquote>
<h2><a id="2-container-diagram%E5%AE%B9%E5%99%A8%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Container diagram  容器图</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105961609537.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105961703163.jpg" alt="" /></p>
<p>Once you understand how your system fits in to the overall IT environment, a really useful next step is to zoom-in to the system boundary with a Container diagram. A &quot;container&quot; is something like a server-side web application, single-page application, desktop application, mobile app, database schema, file system, etc. Essentially, a container is a separately runnable/deployable unit (e.g. a separate process space) that executes code or stores data.</p>
<blockquote>
<p>翻译： 一旦您了解了系统如何适应整个 IT 环境，下一步就非常有用，就是使用容器图放大到系统边界。“容器”类似于服务器端 Web 应用程序、单页应用程序、桌面应用程序、移动应用程序、数据库架构、文件系统等。从本质上讲，容器是一个可单独运行/可部署的单元（例如，一个单独的进程空间），用于执行代码或存储数据。</p>
</blockquote>
<p>The Container diagram shows the high-level shape of the software architecture and how responsibilities are distributed across it. It also shows the major technology choices and how the containers communicate with one another. It's a simple, high-level technology focussed diagram that is useful for software developers and support/operations staff alike.</p>
<blockquote>
<p>翻译： 容器图显示了软件体系结构的高级形状以及如何在其中分配责任。它还显示了主要的技术选择以及容器之间的通信方式。这是一个以高级技术为重点的简单图表，对软件开发人员和支持/操作人员都很有用。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>A single software system.</p>
<blockquote>
<p>翻译： 范围：单个软件系统。</p>
</blockquote>
<h3><a id="primary-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary elements:</h3>
<p>Containers within the software system in scope.</p>
<blockquote>
<p>翻译：主要元素：范围内软件系统内的容器。</p>
</blockquote>
<h3><a id="supporting-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supporting elements:</h3>
<p>People and ### software systems directly connected to the containers.</p>
<blockquote>
<p>翻译：支持元素：直接连接到容器的人员和软件系统。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Technical people inside and outside of the software development team; including software architects, developers and operations/support staff.</p>
<blockquote>
<p>翻译：目标受众：软件开发团队内外的技术人员;包括软件架构师、开发人员和运营/支持人员。</p>
</blockquote>
<h3><a id="recommended-for-most-teams" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recommended for most teams:</h3>
<p>Yes.</p>
<blockquote>
<p>翻译：建议大多数团队：是的。</p>
</blockquote>
<h3><a id="notes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes:</h3>
<p>This diagram says nothing about clustering, load balancers, replication, failover, etc because it will likely vary across different environments (e.g. production, staging, development, etc). This information is better captured via one or more deployment diagrams.</p>
<blockquote>
<p>翻译：注意：此图未提及群集、负载均衡器、复制、故障转移等，因为它可能因不同环境（例如生产、暂存、开发等）而异。通过一个或多个部署关系图可以更好地捕获此信息。</p>
</blockquote>
<h2><a id="3-component-diagram%E7%BB%84%E4%BB%B6%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Component diagram 组件图</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105964483811.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105964603650.jpg" alt="" /></p>
<p>Next you can zoom in and decompose each container further to identify the major structural building blocks and their interactions.</p>
<blockquote>
<p>翻译：接下来，您可以进一步放大和分解每个容器，以识别主要的结构构建块及其交互。</p>
</blockquote>
<p>The Component diagram shows how a container is made up of a number of &quot;components&quot;, what each of those components are, their responsibilities and the technology/implementation details.</p>
<blockquote>
<p>翻译：组件图显示了容器如何由许多“组件”组成，每个组件是什么，它们的职责以及技术/实现详细信息。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>A single container.</p>
<blockquote>
<p>翻译：作用域：单个容器。</p>
</blockquote>
<h3><a id="primary-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary elements:</h3>
<p>Components within the container in scope.</p>
<blockquote>
<p>翻译：主要元素：容器范围内的组件。</p>
</blockquote>
<h3><a id="supporting-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supporting elements:</h3>
<p>Containers (within the software system in scope) plus people and software systems directly connected to the components.</p>
<blockquote>
<p>翻译： 支持元素：容器（在软件系统范围内）以及直接连接到组件的人员和软件系统。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Software architects and developers.</p>
<blockquote>
<p>翻译：目标受众：软件架构师和开发人员。</p>
</blockquote>
<h3><a id="recommended-for-most-teams" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recommended for most teams:</h3>
<p>No, only create component diagrams if you feel they add value, and consider automating their creation for long-lived documentation.</p>
<blockquote>
<p>翻译：建议大多数团队：不可以，只有在您认为组件图可以增加价值时才创建组件图，并考虑自动创建它们以获得长期文档。</p>
</blockquote>
<h2><a id="4-code-diagram%E4%BB%A3%E7%A0%81%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Code diagram 代码图</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105965850683.jpg" alt="" /></p>
<p>Finally, you can zoom in to each component to show how it is implemented as code; using UML class diagrams, entity relationship diagrams or similar.</p>
<blockquote>
<p>翻译：最后，您可以放大每个组件以显示它如何作为代码实现;使用 UML 类图、实体关系图或类似工具。</p>
</blockquote>
<p>This is an optional level of detail and is often available on-demand from tooling such as IDEs. Ideally this diagram would be automatically generated using tooling (e.g. an IDE or UML modelling tool), and you should consider showing only those attributes and methods that allow you to tell the story that you want to tell. This level of detail is not recommended for anything but the most important or complex components.</p>
<blockquote>
<p>翻译：这是一个可选的细节级别，通常可从 IDE 等工具中按需获得。理想情况下，此图将使用工具（例如 IDE 或 UML 建模工具）自动生成，并且您应该考虑仅显示那些允许您讲述要讲述的故事的属性和方法。除了最重要或最复杂的组件外，不建议对任何组件使用此级别的详细信息。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>A single component.</p>
<blockquote>
<p>翻译：作用域：单个组件。</p>
</blockquote>
<h3><a id="primary-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary elements:</h3>
<p>Code elements (e.g. classes, interfaces, objects, functions, database tables, etc) within the component in scope.</p>
<blockquote>
<p>翻译：主要元素：作用域内组件中的代码元素（例如类、接口、对象、函数、数据库表等）。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Software architects and developers.</p>
<blockquote>
<p>翻译：目标受众：软件架构师和开发人员。</p>
</blockquote>
<h3><a id="recommended-for-most-teams" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recommended for most teams:</h3>
<p>No, particularly for long-lived documentation because most IDEs can generate this level of detail on demand.</p>
<blockquote>
<p>翻译：建议大多数团队使用：否，特别是对于长期文档，因为大多数 IDE 都可以按需生成此级别的详细信息。</p>
</blockquote>
<h2><a id="system-landscape-diagram%E7%B3%BB%E7%BB%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>System Landscape diagram 系统</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105970550630.jpg" alt="" /></p>
<p>The C4 model provides a static view of a single software system but, in the real-world, software systems never live in isolation. For this reason, and particularly if you are responsible for a collection/portfolio of software systems, it's often useful to understand how all of these software systems fit together within a given enterprise, organisation, department, etc. Essentially this is a map of the software systems within the chosen scope, with a C4 drill-down for each software system of interest.</p>
<blockquote>
<p>翻译：C4 模型提供了单个软件系统的静态视图，但在现实世界中，软件系统从来都不是孤立存在的。出于这个原因，特别是如果您负责软件系统的集合/组合，了解所有这些软件系统如何在给定的企业、组织、部门等中组合在一起通常很有用。从本质上讲，这是所选范围内软件系统的映射，每个感兴趣的软件系统都有 C4 向下钻取。</p>
</blockquote>
<p>From a practical perspective, a system landscape diagram is really just a system context diagram without a specific focus on a particular software system.</p>
<blockquote>
<p>翻译：从实践的角度来看，系统景观图实际上只是一个系统上下文图，没有特别关注特定的软件系统。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>An enterprise/organisation/department/etc.</p>
<blockquote>
<p>翻译：范围：企业/组织/部门/等。</p>
</blockquote>
<h3><a id="primary-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary elements:</h3>
<p>People and software systems related to the chosen scope.</p>
<blockquote>
<p>翻译：主要元素：与所选范围相关的人员和软件系统。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Technical and non-technical people, inside and outside of the software development team.</p>
<blockquote>
<p>翻译：目标受众：软件开发团队内部和外部的技术人员和非技术人员。</p>
</blockquote>
<h2><a id="dynamic-diagram%E5%8A%A8%E6%80%81%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dynamic diagram 动态图</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105972205701.jpg" alt="" /></p>
<p>A dynamic diagram can be useful when you want to show how elements in the static model collaborate at runtime to implement a user story, use case, feature, etc. This dynamic diagram is based upon a UML communication diagram (previously known as a &quot;UML collaboration diagram&quot;). It is similar to a UML sequence diagram although it allows a free-form arrangement of diagram elements with numbered interactions to indicate ordering.</p>
<blockquote>
<p>翻译：当您想要显示静态模型中的元素如何在运行时协作以实现用户故事、用例、功能等时，动态图可能很有用。此动态图基于 UML 通信图（以前称为“UML 协作图”）。它类似于 UML 序列图，尽管它允许图元素的自由格式排列，并带有编号的交互来指示排序。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>A particular feature, story, use case, etc.</p>
<blockquote>
<p>翻译：范围：特定功能、故事、用例等。</p>
</blockquote>
<h3><a id="primary-and-supporting-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary and supporting elements:</h3>
<p>Your choice - you can show software systems, containers, or components interacting at runtime.</p>
<blockquote>
<p>翻译：主要元素和支持元素：您的选择 - 您可以显示软件系统、容器或组件在运行时进行交互。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Technical and non-technical people, inside and outside of the software development team.</p>
<blockquote>
<p>翻译：目标受众：软件开发团队内部和外部的技术人员和非技术人员。</p>
</blockquote>
<h3><a id="notes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notes:</h3>
<p>Feel free to use a UML sequence diagram if you prefer that visual style.</p>
<blockquote>
<p>翻译：注意：如果您喜欢这种视觉样式，请随意使用 UML 序列图。</p>
</blockquote>
<h2><a id="deployment-diagram%E9%83%A8%E7%BD%B2%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Deployment diagram 部署图</h2>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105974167128.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105974239254.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105974319719.jpg" alt="" /></p>
<p>A deployment diagram allows you to illustrate how instances of software systems and/or containers in the static model are deployed on to the infrastructure within a given deployment environment (e.g. production, staging, development, etc). It's based upon a UML deployment diagram.</p>
<blockquote>
<p>翻译：部署图允许您说明静态模型中的软件系统和/或容器实例如何部署到给定部署环境（例如生产、暂存、开发等）中的基础架构上。它基于 UML 部署图。</p>
</blockquote>
<p>A deployment node represents where an instance of a software system/container is running; perhaps physical infrastructure (e.g. a physical server or device), virtualised infrastructure (e.g. IaaS, PaaS, a virtual machine), containerised infrastructure (e.g. a Docker container), an execution environment (e.g. a database server, Java EE web/application server, Microsoft IIS), etc. Deployment nodes can be nested.</p>
<blockquote>
<p>翻译：部署节点表示软件系统/容器实例的运行位置;也许是物理基础设施（例如物理服务器或设备），虚拟化基础设施（例如IaaS，PaaS，虚拟机），容器化基础设施（例如Docker容器），执行环境（例如数据库服务器，Java EE Web/应用程序服务器，Microsoft IIS）等。部署节点可以嵌套。</p>
</blockquote>
<p>You may also want to include infrastructure nodes such as DNS services, load balancers, firewalls, etc.</p>
<blockquote>
<p>翻译：您可能还希望包括基础架构节点，例如 DNS 服务、负载均衡器、防火墙等。</p>
</blockquote>
<p>Feel free to use icons provided by Amazon Web Services, Azure, etc to complement your deployment diagrams ... just make sure any icons you use are included in your diagram key/legend.</p>
<blockquote>
<p>翻译：随意使用 Amazon Web Services、Azure 等提供的图标来补充您的部署图......只需确保您使用的任何图标都包含在图表键/图例中即可。</p>
</blockquote>
<h3><a id="scope" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scope:</h3>
<p>One or more software systems within a single deployment environment (e.g. production, staging, development, etc).</p>
<blockquote>
<p>翻译：范围：单个部署环境中的一个或多个软件系统（例如生产、暂存、开发等）。</p>
</blockquote>
<h3><a id="primary-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primary elements:</h3>
<p>Deployment nodes, software system instances, and container instances.</p>
<blockquote>
<p>翻译：主要元素：部署节点、软件系统实例和容器实例。</p>
</blockquote>
<h3><a id="supporting-elements" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Supporting elements:</h3>
<p>Infrastructure nodes used in the deployment of the software system.</p>
<blockquote>
<p>翻译：支持元素：用于部署软件系统的基础架构节点。</p>
</blockquote>
<h3><a id="intended-audience" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Intended audience:</h3>
<p>Technical people inside and outside of the software development team; including software architects, developers, infrastructure architects, and operations/support staff.</p>
<blockquote>
<p>翻译：目标受众：软件开发团队内外的技术人员;包括软件架构师、开发人员、基础架构架构师和运营/支持人员。</p>
</blockquote>
<h2><a id="notation%E8%A1%A8%E7%A4%BA%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notation 表示法</h2>
<p>The C4 model is notation independent, and doesn't prescribe any particular notation. As a starting point though, a simple notation that works well on whiteboards, paper, sticky notes, index cards and a variety of diagraming tools is as follows.</p>
<blockquote>
<p>翻译：C4 模型与符号无关，不规定任何特定的符号。不过，作为起点，一个简单的符号在白板、纸张、便笺、索引卡和各种图表工具上都适用，如下所示。</p>
</blockquote>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105976136981.jpg" alt="" /></p>
<p>You can then use colour and shapes to supplement the diagram, either to add additional information or simply to make the diagram more aesthetically pleasing.</p>
<blockquote>
<p>翻译：然后，您可以使用颜色和形状来补充图表，以添加其他信息或只是使图表更美观。</p>
</blockquote>
<h3><a id="c4-and-uml-c4%E5%92%8C-uml" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C4 and UML /C4 和 UML</h3>
<p>Although the example diagrams above are created using a &quot;boxes and lines&quot; notation, the core diagrams can be illustrated using UML with the appropriate use of packages, components and stereotypes. The resulting UML diagrams do tend to lack the same degree of descriptive text though, because adding such text isn't possible (or easy) with some UML tools.</p>
<blockquote>
<p>翻译：尽管上面的示例图是使用“框和线”表示法创建的，但可以使用 UML 并适当使用包、组件和构造型来说明核心图。但是，生成的 UML 图确实往往缺乏相同程度的描述性文本，因为使用某些 UML 工具无法（或轻松）添加此类文本。</p>
</blockquote>
<p>Here are three examples of a System Context, Container and Component diagram for comparison.</p>
<blockquote>
<p>翻译：以下是系统上下文、容器和组件图的三个示例，以供比较。</p>
</blockquote>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105979187286.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105979323777.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105979429374.jpg" alt="" /></p>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105979587869.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105979693145.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105979872889.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105979969132.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105980038417.jpg" alt="" /><br />
<img src="http://cdn.opendatamesh.cn/mweb/17105980100326.jpg" alt="" /></p>
<h3><a id="c4-and-archimate-c4%E5%92%8C-archimate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>C4 and ArchiMate C4 和 ArchiMate</h3>
<p>See <a href="https://www.archimatetool.com/blog/2020/04/18/c4-model-architecture-viewpoint-and-archi-4-7/">C4 Model, Architecture Viewpoint and Archi 4.7 </a>for details of how to create C4 model diagrams with ArchiMate.</p>
<blockquote>
<p>翻译：请参阅 C4 模型、架构视点 和 Archi 4.7，了解如何使用 ArchiMate 创建 C4 模型图的详细信息。</p>
</blockquote>
<h3><a id="diagram-keylegend%E5%9B%BE%E8%A1%A8%E9%94%AE%E5%9B%BE%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Diagram key/legend 图表键/图例</h3>
<p>Any notation used should be as self-describing as possible, but all diagrams should have a key/legend to make the notation explicit. This applies to diagrams created with notations such as UML, ArchiMate and SysML too, as not everybody will know the notation being used.</p>
<blockquote>
<p>翻译：使用的任何符号都应尽可能自我描述，但所有图表都应具有键/图例以使符号显式。这也适用于使用 UML、ArchiMate 和 SysML 等符号创建的图表，因为不是每个人都知道所使用的符号。</p>
</blockquote>
<p><img src="http://cdn.opendatamesh.cn/mweb/17105961703163.jpg" alt="" /></p>
<h3><a id="notation-notation-notation%E7%AC%A6%E5%8F%B7%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%8C%E7%AC%A6%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Notation, notation, notation 符号，符号，符号</h3>
<p>Although the C4 model is an abstraction-first approach and notation independent, you still need to ensure that your diagram notation makes sense, and that the diagrams are comprehensible. A good way to think about this is to ask yourself whether each diagram can stand alone, and be (mostly) understood without a narrative. You can use this short <a href="https://c4model.com/review/">software architecture diagram review checklist </a>to help. And here are some recommendations related to notation.</p>
<blockquote>
<p>翻译：尽管 C4 模型是一种抽象优先的方法，并且与符号无关，但您仍然需要确保图表符号有意义，并且图表是可理解的。思考这个问题的一个好方法是问问自己，每个图表是否可以独立存在，并且（大部分）在没有叙述的情况下被理解。您可以使用这个简短的软件架构图审查清单来提供帮助。这里有一些与符号相关的建议。</p>
</blockquote>
<h4><a id="diagrams%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Diagrams 图</h4>
<p>Every diagram should have a title describing the diagram type and scope (e.g. &quot;System Context diagram for My Software System&quot;).</p>
<blockquote>
<p>翻译：每个图表都应该有一个描述图表类型和范围的标题（例如，“我的软件系统的系统上下文图”）。<br />
Every diagram should have a key/legend explaining the notation being used (e.g. shapes, colours, border styles, line types, arrow heads, etc).<br />
翻译：每个图表都应该有一个键/图例来解释所使用的符号（例如形状、颜色、边框样式、线条类型、箭头等）。<br />
Acronyms and abbreviations (business/domain or technology) should be understandable by all audiences, or explained in the diagram key/legend.<br />
翻译：首字母缩略词和缩写词（业务/领域或技术）应为所有受众所理解，或在图表键/图例中解释。</p>
</blockquote>
<h4><a id="elements%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Elements 元素</h4>
<p>The type of every element should be explicitly specified (e.g. Person, Software System, Container or Component).</p>
<blockquote>
<p>翻译：应明确指定每个元素的类型（例如，人员、软件系统、容器或组件）。<br />
Every element should have a short description, to provide an &quot;at a glance&quot; view of key responsibilities.<br />
翻译：每个元素都应该有一个简短的描述，以提供关键职责的“一目了然”视图。<br />
Every container and component should have a technology explicitly specified.<br />
翻译：每个容器和组件都应具有明确指定的技术。</p>
</blockquote>
<h4><a id="relationships%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Relationships 关系</h4>
<p>Every line should represent a unidirectional relationship.</p>
<blockquote>
<p>翻译：每条线都应该表示一个单向关系。<br />
Every line should be labelled, the label being consistent with the direction and intent of the relationship (e.g. dependency or data flow). Try to be as specific as possible with the label, ideally avoiding single words like, &quot;Uses&quot;.<br />
翻译：每一行都应该被标记，标签与关系的方向和意图一致（例如依赖关系或数据流）。尽量使标签更具体，最好避免使用“用途”等单个词。<br />
Relationships between containers (typically these represent inter-process communication) should have a technology/protocol explicitly labelled.<br />
翻译：容器之间的关系（通常表示进程间通信）应具有显式标记的技术/协议。</p>
</blockquote>
<h3><a id="alternative-visualisations%E6%9B%BF%E4%BB%A3%E5%8F%AF%E8%A7%86%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Alternative visualisations 替代可视化</h3>
<p>Finally, don't feel that you need to always use a traditional &quot;boxes and arrows&quot; diagram. Although this is usually the default approach, there are other, often interactive, visualisations that can be used to show the same C4 model abstractions in very different ways.</p>
<blockquote>
<p>翻译： 最后，不要觉得你需要总是使用传统的“方框和箭头”图。虽然这通常是默认方法，但还有其他（通常是交互式的）可视化可用于以非常不同的方式显示相同的 C4 模型抽象。</p>
</blockquote>
<ul>
<li>Traditional &quot;boxes and arrows&quot; diagrams are the default approach for documentation and presentations.</li>
</ul>
<blockquote>
<p>翻译：传统的“方框和箭头”图是文档和演示文稿的默认方法。</p>
</blockquote>
<ul>
<li>A D3.js force-directed graph is a very concise way to visualise larger software architectures, also providing an easy way to explore dependencies.</li>
</ul>
<blockquote>
<p>翻译：D3.js力导向图是可视化大型软件架构的一种非常简洁的方法，也提供了一种探索依赖关系的简单方法。</p>
</blockquote>
<ul>
<li>Ilograph's interactive diagrams provide a way to selectively zoom in and out, allowing you to explore your entire software architecture model.</li>
</ul>
<blockquote>
<p>翻译：Ilograph 的交互式图表提供了一种有选择地放大和缩小的方法，允许您探索整个软件架构模型。</p>
</blockquote>
<h3><a id="tooling%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tooling 工具</h3>
<p>For design sessions, you might find a whiteboard or flip chart paper better for collaboration, and iterating quickly. For long-lived documentation, there are a number of tools can help create software architecture diagrams based upon the C4 model.</p>
<blockquote>
<p>翻译：对于设计会议，您可能会发现白板或活动挂图纸更适合协作，并且可以快速迭代。对于长期文档，有许多工具可以帮助创建基于 C4 模型的软件架构图。</p>
</blockquote>
<p>Don't forget to ask yourself some questions when looking at tooling, to understand the features you need. Who are the diagram authors, and how technical are they? A &quot;drag and drop&quot; UI vs &quot;diagrams as code&quot;? Data stored in git next to your source code vs stored in the tool/cloud service? Closed vs open data format? Interactive vs static diagrams? Free vs paid vs open source? Short-lived vs long-lived documentation? Team only diagramming vs enterprise-wide modelling? Who is the diagram audience, and how would they access the diagrams/documentation?</p>
<blockquote>
<p>翻译：在查看工具时，不要忘记问自己一些问题，以了解您需要的功能。谁是图表作者，他们的技术水平如何？“拖放式”UI与“图表即代码”？存储在源代码旁边的 git 中的数据与存储在工具/云服务中的数据？封闭式数据格式与开放式数据格式？交互式图表与静态图表？免费 vs 付费 vs 开源？短期文档与长期文档？仅团队图表与企业范围的建模？谁是图表受众，他们将如何访问图表/文档？</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2024/03/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='System%20architecture.html'>System architecture</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>leadedx</h1>
                <div class="site-des"></div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/leadedx/" title="GitHub">GitHub</a>

  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="datamesh.html"><strong>Data Mesh</strong></a>
        
            <a href="System%20architecture.html"><strong>System architecture</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Books.html"><strong>Books</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="17118891531585.html">Data Product Canvas</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17118888075897.html">数据产品画布</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17118887373917.html">数据产品的内部结构</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17118884631387.html">Data Mesh 实践</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17118880625718.html">Data Mesh in Action：全面指南解读去中心化数据架构</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
